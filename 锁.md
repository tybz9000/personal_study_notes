# 事务

事务是数据库访问和更新数据库的一个程序执行单元

**目的**

失败后恢复到正常

异常状态仍然保持一致性

成功后，从一种状态到另外一种状态，并且能持久化

简化编程模型，不需要去考虑潜在错误和并发问题

**原子性atomicity**

要么全部成功，要么全部失败

**一致性consistency**

保证事务只能把数据库从一个有效（正确）的状态转移到另一个有效的状态

数据的一致性：

**隔离性isolation**

不同事务之间互相隔离

**持久性durability**

事务提交完成，改动即生效

**AID是数据库的属性，而一致性是应用层的属性，我们设计了一致性的要求，而事务提供了保证。比如人员角色，加了人员就加角色。不能因为事务失败导致只加了人员就没加上角色。AID为手段，C为目的**

## **事务隔离级别**

### 问题：

- ##### 脏读：

A事务执行过程中，B事务读了A事务的更改结果，然后A事务回滚了

- ##### 不可重复读

B事务读取了两次数据，两次读取过程中，A事务更改了数据

- ##### 幻读

B事务读取了两次数据，两次读取过程中，A事务增加、删除了数据

### 隔离级别：

##### 读未提交：

所有事务，可以看到其他事务未提交的更改，会造成脏读

##### 读已提交：

所有事务，可以看到其他事务已提交的修改，规避脏读，无法规避不可重复读和幻读

##### 可重复读：

同一个事务执行过程中，查到的数据行不会变化，规避幻读之外的问题

##### 可串行化：

强行串行，解决一切并发事务问题



# MySQL

## 架构

服务层：连接管理、查询缓存、解析、查询优化、执行器

存储引擎：可插拔式存储引擎

![](D:\真学习文件\图片\MySQL_SERVER架构.jpg)



## 索引：

**帮助数据库高效获取数据的数据结构**

**用B+树**，M值由磁盘块来定义

**不用Hash表**，没法大于小于和Like，占内存

**不用二叉树**，每层深度太多，内容太少，io太多

## 存储引擎

**数据库存储机制，如何实现数据存储，如何建立索引和更新，如何查询**

最常用InnoDB、MyISAM、MEMORY、ARCHIVE

**MyISAM**

使用B+树做索引

不支持事务、不支持行级锁，只支持并发插入的表锁，主要用于高负载的select

有一个表使用这个引擎，那么事务就没法用

MyISAM存储引擎使用的是非聚集索引，主键与其他索引的叶子节点都存储了指向数据的指针

**InnoDB**

默认存储引擎 5.1以后

支持行级别锁

支持事务

MyISAM存储引擎使用的是非聚集索引，主键与其他索引的叶子节点都存储了指向数据的指针使用聚集索引，主键的叶子节点是**该行的数据**，**存放的物理顺序**和列中的顺序一样，其他索引指向主键，整个表变成了一个B+树

# MyBatis

源码执行逻辑

构建，根据XML配置变成需要的对象

执行，构建完成的基础上，执行SQL，与JDBC进行交互

SqlSessionFactory

用XNode解析XML

# TiDB

## 优势

分布式关系型数据库, 一键水平扩容, 缩容, 提高存储容量, 保障存储性能

高可用, 多副本, 多数写入成功事务才能提交

兼容MySQL 5.7, MySQL迁移到TiDB不需要大规模代码改动

## 架构

PD: 管理组件, 管理TiKV节点实时数据分布, 集群拓扑结构

TiDB: 计算组件, 解析优化SQL, 生成分布式执行计划, 聚合计算结果

TiKV: 存储组件

## 存储结构

巨型Map: 按Key的二进制排序, 顺序分片存储

**分布式存储, 运算下推存储**

## Join算法

Index Join 同 MySQL, A表中匹配一条记录, 接着去B表中查匹配响应的记录

Hash Join  从 A B 两表根据过滤条件分别查出数据, 然后根据关联条件进行关联过滤, 可以并行执行, 消耗内存多

# MVCC

多版本并发控制
